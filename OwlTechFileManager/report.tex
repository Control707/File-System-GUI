\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}


% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{CS 3502: Operating Systems \\ Project 3: File System Implementation}}
\author{Zakaria \\ Kennesaw State University}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
The goal of this project was to develop a robust file management system with a graphical user interface (GUI). The application, named ``OwlTech File Manager,'' allows users to perform fundamental file system operations such as creating, reading, updating, deleting, and renaming files and directories. This project serves to demonstrate a practical understanding of how operating systems manage files and how these low-level operations can be abstracted into a user-friendly interface.

\subsection{Technology Choice}
For this implementation, \textbf{Python} was selected as the programming language, paired with the \textbf{Tkinter} library for the GUI.

\begin{itemize}
    \item \textbf{Python}: Chosen for its extensive standard library, specifically the \texttt{os}, \texttt{shutil}, and \texttt{pathlib} modules, which provide high-level abstractions for OS interactions. This allows for rapid development and clean, readable code.
    \item \textbf{Tkinter}: As Python's standard GUI interface, it requires no external dependencies or complex installation steps. It provides all the necessary widgets (Treeview, Text Editor, Dialogs) to build a functional desktop application.
\end{itemize}

\section{Design and Architecture}

\subsection{High-Level Architecture}
The application follows a modular design pattern, separating the backend logic from the frontend user interface.

\begin{itemize}
    \item \textbf{Backend (FileManager)}: This layer handles all direct interactions with the operating system. It exposes methods for CRUD operations and directory listing. It returns data in a structured format (dictionaries) indicating success or failure, ensuring the UI doesn't need to handle raw OS exceptions.
    \item \textbf{Frontend (FileExplorerApp)}: This layer is responsible for the visual presentation. It consumes the \texttt{FileManager} API to display files and directories and captures user inputs to trigger operations.
\end{itemize}

\subsection{Key Design Decisions}
\begin{itemize}
    \item \textbf{Pathlib}: The \texttt{pathlib} library was used instead of raw string manipulation for file paths. This ensures the application is cross-platform (working on Windows, macOS, and Linux) without modification.
    \item \textbf{State Management}: The application maintains a \texttt{current\_path} state in the backend. The frontend queries this state to render the view, ensuring the UI is always in sync with the underlying file system.
    \item \textbf{Unified Error Handling}: All backend methods return a dictionary containing a \texttt{success} boolean. If an operation fails, an \texttt{error} message is returned. This allows the UI to display consistent error dialogs to the user.
\end{itemize}

\section{Implementation}

\subsection{Core Algorithms and Approaches}
The core functionality relies on mapping user actions to Python's standard library functions:

\begin{itemize}
    \item \textbf{Listing Directory}: The \texttt{pathlib.Path.iterdir()} method is used to iterate over items. We sort the results so that directories appear before files, enhancing readability.
    \item \textbf{File Operations}: 
    \begin{itemize}
        \item \textbf{Create}: \texttt{open(path, 'w')} creates new files.
        \item \textbf{Read}: \texttt{open(path, 'r')} reads content.
        \item \textbf{Update}: Overwriting is handled by opening files in write mode.
        \item \textbf{Delete}: \texttt{shutil.rmtree()} is used for directories (recursive delete) and \texttt{path.unlink()} for files.
    \end{itemize}
\end{itemize}

\subsection{GUI Integration}
The GUI uses a \texttt{ttk.Treeview} widget to display the file list. Columns show file size and modification time. A \texttt{ScrolledText} widget serves as the integrated file viewer and editor. Double-clicking an item triggers navigation (if directory) or opens the file (if text file).

\subsection{Error Handling Strategy}
Robust error handling was a priority. Every OS operation is wrapped in a \texttt{try-except} block. Common exceptions like \texttt{FileExistsError}, \texttt{PermissionError}, and \texttt{FileNotFoundError} are caught. Instead of crashing, the application returns a descriptive error message, which is then shown to the user via a \texttt{messagebox.showerror} dialog.

\section{Testing}

\subsection{Test Scenarios}
Testing was conducted in two phases: automated unit testing for the backend and manual testing for the GUI.

\subsubsection{Automated Backend Tests}
A \texttt{unittest} suite was created to verify the \texttt{FileManager} class.
\begin{itemize}
    \item \textbf{Create}: Verified files and directories are physically created on the disk.
    \item \textbf{Read/Update}: Verified content integrity after write and update operations.
    \item \textbf{Delete}: Confirmed items are removed.
    \item \textbf{Navigation}: Tested moving into subdirectories and back up to parent directories.
\end{itemize}
\textbf{Result}: All automated tests passed successfully.

\subsubsection{Manual GUI Tests}
\begin{itemize}
    \item \textbf{Edge Cases}: Tested creating files with existing names (handled gracefully with error message).
    \item \textbf{Navigation}: Navigated deep into nested folders and returned home.
    \item \textbf{Editing}: Opened a text file, modified it, saved it, and reopened it to verify persistence.
\end{itemize}

\section{Challenges and Solutions}

\subsection{Technical Difficulties}
\begin{itemize}
    \item \textbf{Directory vs. File Distinction}: Initially, the logic to distinguish between opening a file and entering a directory was mixed. 
    \item \textbf{Solution}: I separated the logic by checking \texttt{is\_dir()} explicitly. If it's a directory, we change the current path; if it's a file, we load its content.
    
    \item \textbf{UI Responsiveness}: Large directories could potentially freeze the UI.
    \item \textbf{Solution}: While not fully implemented for this scope, the design allows for the \texttt{list\_directory} method to be optimized or threaded in the future. For now, efficient sorting and minimal metadata fetching keep it responsive.
\end{itemize}

\section{Conclusion}
The OwlTech File Manager project successfully meets all functional requirements. It provides a clean, intuitive interface for managing files and demonstrates the effective use of OS-level system calls within a high-level application.

\subsection{Future Improvements}
\begin{itemize}
    \item Implement Copy/Paste functionality (Clipboard support).
    \item Add drag-and-drop support for easier file organization.
    \item Add a search bar to filter files in the current view.
\end{itemize}

\subsection{Reflection}
This project reinforced the concepts of file systems, specifically how metadata (permissions, timestamps) is stored and accessed. It also highlighted the importance of separating the presentation layer from the logic layer to make testing and maintenance easier.

\end{document}
